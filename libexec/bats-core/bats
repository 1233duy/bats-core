#!/usr/bin/env bash
set -e

export BATS_VERSION='1.2.0'

version() {
  printf 'Bats %s\n' "$BATS_VERSION"
}

abort() {
  printf 'Error: %s\n' "$1" >&2
  usage >&2
  exit 1
}

usage() {
  local cmd="${0##*/}"
  local line

  while IFS= read -r line; do
    printf '%s\n' "$line"
  done <<END_OF_HELP_TEXT
Usage: $cmd [-cr] [-f <regex>] [-j <jobs>] [-p | -t] <test>...
       $cmd [-h | -v]

  <test> is the path to a Bats test file, or the path to a directory
  containing Bats test files (ending with ".bats").

  -c, --count               Count the number of test cases without running any tests
  -f, --filter              Filter test cases by names matching the regular expression
  -F, --formatter           Switch between formatters (Default: tap, Options: junit, pretty, tap)
  -h, --help                Display this help message
  -j, --jobs                Number of parallel jobs to run (requires GNU parallel)
  --parallel-preserve-environment 
                   Preserve the environment When running via GNU parallel (run 
                   \`parallel --record-env\` before!)
  --no-tempdir-cleanup
                   Prevent bats from deleting the temporary directory that
                   contains outputs from the test run
  -o, --output              A directory to output reports to
  -p, --pretty              [DEPRECATED] Show results in pretty format (default for terminals), use "--formatter pretty" instead
  -r, --recursive           Include tests in subdirectories
  -t, --tap                 [DEPRECATED] Show results in TAP format, use "--formatter tap" instead
  -T, --timing              Add timing information
  -v, --version             Display the version number

  For more information, see https://github.com/bats-core/bats-core

END_OF_HELP_TEXT
}

expand_link() {
  IFS='/' read -ra parts <<<"$1"

  # Starting point.
  local path="/"
  [[ "$1" =~ ^/ ]] || path="."

  # Process each component.
  for part in "${parts[@]}"
  do
    # All components must exist.
    [ -e "$path/$part" ] || return 1

    # If it's a link, we need to resolve it first.
    [ -L "$path/$part" ] && part="$(readlink "$path/$part")"

    # If the component starts with "/" we stomp the existing $path.
    [[ "$part" =~ ^/ ]] && path=""

    # Add the component to the path.
    path+="/$part"
  done

  # Remove any duplicate slashes.
  echo "$path" | tr -s /
}

expand_path() {
  local path="${1%/}"
  local dirname="${path%/*}"
  local result="$2"

  if [[ "$dirname" == "$path" ]]; then
    dirname="$PWD"
  else
    cd "$dirname"
    dirname="$PWD"
    cd "$OLDPWD"
  fi
  printf -v "$result" '%s/%s' "$dirname" "${path##*/}"
}

BATS_LIBEXEC="$(dirname "$(expand_link "${BASH_SOURCE[0]}")")"
export BATS_CWD="$PWD"
export BATS_TEST_PATTERN="^[[:blank:]]*@test[[:blank:]]+(.*[^[:blank:]])[[:blank:]]+\{(.*)\$"
export BATS_TEST_FILTER=
export PATH="$BATS_LIBEXEC:$PATH"
export BATS_ROOT_PID=$$
if [[ -z "$TMPDIR" ]]; then
  export BATS_TMPDIR="/tmp"
else
  export BATS_TMPDIR="${TMPDIR%/}"
fi
export BATS_RUN_TMPDIR="$BATS_TMPDIR/bats-run-$BATS_ROOT_PID"

arguments=()

# Unpack single-character options bundled together, e.g. -cr, -pr.
for arg in "$@"; do
  if [[ "$arg" =~ ^-[^-]. ]]; then
    index=1
    while option="${arg:$((index++)):1}"; do
      if [[ -z "$option" ]]; then
        break
      fi
      arguments+=("-$option")
    done
  else
    arguments+=("$arg")
  fi
  shift
done

set -- "${arguments[@]}"
arguments=()

unset flags recursive formatter_flags
flags=()
formatter_flags=()
formatter='tap'
recursive=
tempdir_cleanup=1
output=
if [[ -z "${CI:-}" && -t 0 && -t 1 ]] && command -v tput >/dev/null; then
	formatter='pretty'
fi

while [[ "$#" -ne 0 ]]; do
  case "$1" in
	-h | --help)
    version
    usage
    exit 0
    ;;
	-v | --version)
    version
    exit 0
    ;;
	-c | --count)
    flags+=('-c')
    ;;
	-f | --filter)
    shift
    flags+=('-f' "$1")
    ;;
	-F | --formatter)
		shift
		if [[ $1 =~ ^(pretty|junit|tap)$ ]]; then
			formatter="$1"
		else
			printf "Unknown formatter '%s', valid options are pretty, junit, tap\n" "$1"
			exit 1
		fi
		;;
	-o | --output)
    shift
		output="$1"
		;;
	-p | --pretty)
		formatter='pretty'
		;;
	-j | --jobs)
		shift
    flags+=('-j' "$1")
    ;;
	-r | --recursive)
    recursive=1
    ;;
	-t | --tap)
		formatter='tap'
    ;;
	-T | --timing)
		flags+=('-T')
		formatter_flags+=('-T')
    ;;
  --parallel-preserve-environment)
    flags+=("--parallel-preserve-environment")
    # check if parallel's env setup was run before
    # will print on stderr and return 255 on failure
    # suppress stdout (on success)
    parallel --env _ echo ::: 1 >/dev/null || exit 1
    ;;
  --no-tempdir-cleanup)
    tempdir_cleanup=''
    ;;
  -*)
    abort "Bad command line option '$1'"
    ;;
  *)
    arguments+=("$1")
    ;;
  esac
  shift
done

if [[ -d "$BATS_RUN_TMPDIR" ]]; then
  printf "Error: BATS_RUN_TMPDIR (%s) already exists\n" "$BATS_RUN_TMPDIR" >&2
  printf "Reusing old run directories can lead to unexpected results ... aborting!\n" >&2
  exit 1
fi
mkdir -p "$BATS_RUN_TMPDIR"
if [[ -n "$tempdir_cleanup" ]]; then
  trap 'rm -rf "$BATS_RUN_TMPDIR"' ERR EXIT
fi

if [[ "$formatter" != "tap" ]]; then
	flags+=('-x')
fi
if [[ "$formatter" == "junit" ]]; then
	flags+=('-T')
	formatter_flags+=('-T')
fi

if [[ "${#arguments[@]}" -eq 0 ]]; then
  abort 'Must specify at least one <test>'
fi

filenames=()
for filename in "${arguments[@]}"; do
  expand_path "$filename" 'filename'

  if [[ -d "$filename" ]]; then
    shopt -s nullglob
    if [[ "$recursive" -eq 1 ]]; then
      while IFS= read -r -d $'\0' file; do
        filenames+=("$file")
      done < <(find "$filename" -type f -name '*.bats' -print0 | sort -z)
    else
      for suite_filename in "$filename"/*.bats; do
        filenames+=("$suite_filename")
      done
    fi
    shopt -u nullglob
  else
    filenames+=("$filename")
  fi
done

# shellcheck source=lib/bats-core/validator.bash
source "$BATS_ROOT/lib/bats-core/validator.bash"

set -o pipefail execfail
[[ -n "$output" ]] && export BATS_REPORT_OUTPUT_PATH="$output"
exec bats-exec-suite "${flags[@]}" "${filenames[@]}" | bats_test_count_validator | "bats-format-$formatter" "${formatter_flags[@]}"
