#!/usr/bin/env bash
set -eET

export flags=()
num_jobs=1
filter=''
extended_syntax=''

while [[ "$#" -ne 0 ]]; do
  case "$1" in
  -c) ;;

  -f)
    shift
    filter="$1"
    flags+=('-f' "$filter")
    ;;
  -j)
    shift
    num_jobs="$1"
    ;;
  -T)
    flags+=('-T')
    ;;
  -x)
    flags+=('-x')
    extended_syntax=1
    ;;
  *)
    break
    ;;
  esac
  shift
done

filename=$1
TESTS_FILE="$2"

if [[ ! -f "$filename" ]]; then
  printf 'Testfile "%s" not found\n' "$filename" >&2
  exit 1
fi

BATS_TEST_FILENAME="$filename"

# shellcheck source=lib/bats-core/preprocessing.bash
# shellcheck disable=SC2153
source "$BATS_ROOT/lib/bats-core/preprocessing.bash"

bats_run_setup_file() {
  # shellcheck source=lib/bats-core/tracing.bash
  # shellcheck disable=SC2153
  source "$BATS_ROOT/lib/bats-core/tracing.bash"
  # shellcheck source=lib/bats-core/test_functions.bash
  # shellcheck disable=SC2153
  source "$BATS_ROOT/lib/bats-core/test_functions.bash"

  exec 3<&1

  BATS_STACK_TRACE=()
  # shellcheck disable=2034
  BATS_CURRENT_STACK_TRACE=() # used in tracing.bash

  # these are defined only to avoid errors when referencing undefined variables down the line
  # shellcheck disable=2034
  BATS_TEST_NAME=      # used in tracing.bash
  # shellcheck disable=2034
  BATS_TEST_COMPLETED= # used in tracing.bash

  BATS_SETUP_FILE_COMPLETED=
  BATS_TEARDOWN_FILE_COMPLETED=
  # shellcheck disable=2034
  BATS_ERROR_STATUS= # used in tracing.bash
  trap 'bats_debug_trap "$BASH_SOURCE"' DEBUG
  trap 'bats_error_trap' ERR
  trap 'bats_file_teardown_trap' EXIT

  touch "$BATS_OUT"
  # get the setup_file/teardown_file functions for this file (if it has them)
  # shellcheck disable=SC1090
  source "$BATS_TEST_SOURCE"
  setup_file >>"$BATS_OUT" 2>&1

  BATS_SETUP_FILE_COMPLETED=1
}

bats_run_teardown_file() {
  # avoid running the therdown trap due to errors in teardown_file
  trap 'bats_file_exit_trap' EXIT
  local status=0
  # rely on bats_error_trap to catch failures
  teardown_file >>"$BATS_OUT" 2>&1

  BATS_TEARDOWN_FILE_COMPLETED=1
}

bats_file_teardown_trap() {
  bats_error_trap
  local status=0
  bats_run_teardown_file

  bats_file_exit_trap
}

bats_file_exit_trap() {
  trap - ERR EXIT
  if [[ -z "$BATS_SETUP_FILE_COMPLETED" || -z "$BATS_TEARDOWN_FILE_COMPLETED" ]]; then
    if [[ -z "$BATS_SETUP_FILE_COMPLETED" ]]; then
      FAILURE_REASON='setup_file'
    else
      FAILURE_REASON='teardown_file'
    fi
    printf "not ok %d %s\n" "$((test_number_in_suite + 1))" "$FAILURE_REASON failed" >&3
    bats_print_stack_trace "${BATS_STACK_TRACE[@]}" >&3
    bats_print_failed_command >&3
    while IFS= read -r line; do
      printf "# %s\n" "$line"
    done <"$BATS_OUT" >&3
    if [[ -n "$line" ]]; then
      printf '# %s\n' "$line"
    fi
    rm -rf "$BATS_OUT"
    status=1
  fi
  bats_cleanup_preprocessed_source
  exit $status
}

function setup_file() {
  return 0
}

function teardown_file() {
  return 0
}

bats_parallel_exec_test() { # $1 = test_output_dir, the rest is forwarded to bats-exec-test
  test_output_dir="$1"
  mkdir -p "$test_output_dir"
  shift

  # store the pid for waiting on finish
  printf "%d" "$$" > "$test_output_dir/pid"

  bats-exec-test "$@" 2>"$test_output_dir/stderr" >"$test_output_dir/stdout"

  # store the result for marking end and retrieving errors
  printf "%d" "$?" > "$test_output_dir/exitcode"
}

# make visible for GNU parallel
export -f bats_parallel_exec_test

bats_run_tests_in_parallel() {
  for test_name in "${tests_to_run[@]}"; do
    # Only handle non-empty lines
    if [[ $test_name ]]; then
      ((++test_number_in_suite))
      ((++test_number_in_file))
      # parallelize across files using parallel's semaphore mode
      # shellcheck disable=SC2154 #bats_parallel_args is inherited from exec-suite
      parallel --semaphore -j "$num_jobs" "${bats_parallel_args[@]}" -- bats_parallel_exec_test "$output_folder/$test_number_in_suite" "${flags[@]}" "$filename" "$test_name" "$test_number_in_suite" "$test_number_in_file"
    fi
  done
}

# forward the stdin/stderr output of the test with the given number
# this will block until the test was started and finished before printig anything
# this will also return the test's exit code
bats_forward_output_of_test() {
  test_number="$1"
  test_output_dir="$output_folder/$test_number"
  # wait for test to start
  until [ -e "$test_output_dir/pid" ]
  do
    sleep 1
  done
  # wait for the test to be finished if it hasn't yet
  if [[ ! -e "$test_output_dir/exitcode" ]]; then
    # get the test's pid
    test_pid=$(cat "$test_output_dir/pid")
    # GNU parallel semaphore's subprocess will not be our child, 
    # we cannot use `wait` but we can `tail`!
    tail --pid="$test_pid" -f /dev/null
  fi
  # wait for tests to finish in the order they were started and output their results as they come in
  cat "$test_output_dir/stdout"
  # additionally output stderr as parallel does by default
  cat "$test_output_dir/stderr" >&2
  # retrieve failure
  return "$(cat "$test_output_dir/exitcode")"
}

bats_run_tests() {
  status=0
  tests_to_run=()
  local line_number=0
  # the global test number must be visible to traps -> not local
  first_test_number_in_suite=''
  while read -r test_line; do
    test_file=${test_line%%$'\t'*}
    test_name=${test_line##*$'\t'}
    if [[ "$test_file" == "$filename" ]]; then
      tests_to_run+=("$test_name")
      # save the first test's number for later iteration
      # this assumes that tests for a file are stored consecutive in the file!
      if [[ -z "$first_test_number_in_suite" ]]; then
        first_test_number_in_suite=$line_number
      fi
    fi
    ((++line_number))
  done <"$TESTS_FILE"

  test_number_in_suite="$first_test_number_in_suite"
  test_number_in_file=0
  if [[ "$num_jobs" != 1 ]]; then
    output_folder="$BATS_RUN_TMPDIR/parallel_output"
    # do in background to not block output further down
    bats_run_tests_in_parallel &

    last_test_number_of_file_in_suite=$(( first_test_number_in_suite + ${#tests_to_run[@]} - 1))
    # forward the remaining test's outputs in their order
    # this will block per test until it is finished
    for number_in_suite_of_test_to_end in $(seq $first_test_number_in_suite $last_test_number_of_file_in_suite); do
      bats_forward_output_of_test "$((number_in_suite_of_test_to_end+1))" || status=1
    done
  else
    for test_name in "${tests_to_run[@]}"; do
      # Only handle non-empty lines
      if [[ $test_name ]]; then
        ((++test_number_in_suite))
        ((++test_number_in_file))
        # deal with emtpty flags to avoid spurious "unbound variable" errors on Bash 4.3 and lower
        if [[ "${#flags[@]}" -gt 0 ]]; then
          bats-exec-test "${flags[@]}" "$filename" "$test_name" "$test_number_in_suite" "$test_number_in_file" || status=1
        else
          bats-exec-test "$filename" "$test_name" "$test_number_in_suite" "$test_number_in_file" || status=1
        fi
      fi
    done
  fi
  export status
}

if [[ -n "$extended_syntax" ]]; then
  printf "suite %s\n" "$(basename "$filename")"
fi

bats_preprocess_source "$filename"
bats_run_setup_file
bats_run_tests
bats_run_teardown_file

exit $status
