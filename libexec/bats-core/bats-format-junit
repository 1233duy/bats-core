#!/usr/bin/env bash
set -euo pipefail

BASE_PATH=.

while [[ "$#" -ne 0 ]]; do
  case "$1" in
    --base-path)
      shift
      # the relative path root to use for reporting filenames
      # this is mainly intended for suite mode, where this will be the suite root folder
      BASE_PATH="$1"
      # use the containing directory when --base-path is a file
      if [[ ! -d "$BASE_PATH" ]]; then
        BASE_PATH="$(dirname "$BASE_PATH")"
      fi
      # get the absolute path
      BASE_PATH="$(cd "$BASE_PATH"; pwd)"
      # ensure the path ends with / to strip that later on
      if [[ "${BASE_PATH}" != *"/" ]]; then
        BASE_PATH="$BASE_PATH/"
      fi
    ;;
  esac
  shift
done

index=0

init_suite() {
  suite_test_exec_time=0
  # since we have to print the suite header before its contents but we don't know the contents before the header, 
  # we have to buffer the contents
  _suite_buffer=""
}

_buffer_log=
init_file() {
  file_count=0
  file_failures=0
  file_skipped=0
  file_exec_time=0
  _buffer=""
  _buffer_log=""
}

host() {
  local hostname="${HOST:-}"
  [[ -z "$hostname" ]] && hostname="${HOSTNAME:-}"
  [[ -z "$hostname" ]] && hostname="$(uname -n)"
  [[ -z "$hostname" ]] && hostname="$(hostname -f)"

  echo "$hostname"
}

# convert $1 (time in milliseconds) to seconds
milliseconds_to_seconds() {
  # we cannot rely on having bc for this calculation
  full_seconds=$(($1 / 1000))
  remaining_milliseconds=$(($1 % 1000))
  if [[ $remaining_milliseconds -eq 0 ]]; then
    printf "%d" "$full_seconds"
  else
    printf "%d.%03d" "$full_seconds" "$remaining_milliseconds"
  fi
}

suite_header() {
  printf "<?xml version=\"1.0\" encoding=\"UTF-8\"?>
<testsuites time=\"%s\">\n" "$(milliseconds_to_seconds "${suite_test_exec_time}")"
}

file_header() {
  timestamp=$(date -u +"%Y-%m-%dT%H:%M:%S")
  printf "<testsuite name=\"%s\" tests=\"%s\" failures=\"%s\" errors=\"0\" skipped=\"%s\" time=\"%s\" timestamp=\"%s\" hostname=\"%s\">\n" \
                     "$(xml_escape "${class}")" "${file_count}" "${file_failures}" "${file_skipped}" "$(milliseconds_to_seconds "${file_exec_time}")" "${timestamp}" "$(host)"
}

file_footer() {
  printf "</testsuite>\n"
}

suite_footer() {
  printf "</testsuites>\n"
}

pass() {
  printf "    <testcase classname=\"%s\" name=\"%s\" time=\"%s\"/>\n" "$(xml_escape "${class}")" "$(xml_escape "${name}")" "$(milliseconds_to_seconds "${test_exec_time}")"
}

xml_escape() {
  output=${1//&/&amp;}
  output=${output//</&lt;}
  output=${output//>/&gt;}
  output=${output//'"'/&quot;}
  output=${output//\'/&#39;}
  local CONTROL_CHAR=$'\033'
  output="${output//$CONTROL_CHAR/&#27;}"
  printf "%s" "$output"
}

fail() {
  printf "    <testcase classname=\"%s\" name=\"%s\" time=\"%s\">
      <failure type=\"failure\">%s</failure>
    </testcase>\n" "$(xml_escape "${class}")" "$(xml_escape "${name}")" "$(milliseconds_to_seconds "${test_exec_time}")" "$(xml_escape "$1")"
}

skip() {
  # shellcheck disable=SC2183
  printf "    <testcase classname=\"%s\" name=\"%s\" time=\"%s\">
        <skipped>%s</skipped>
    </testcase>\n" "$(xml_escape "${class}")" "$(xml_escape "${name}")" "$(milliseconds_to_seconds "${test_exec_time}")" "$(xml_escape "$1")"
}

suite_buffer() {
  local output
  output="$("$@"; printf "x")" # use x marker to avoid losing trailing newlines
  _suite_buffer="${_suite_buffer}${output%x}"
}

suite_flush() {
  echo -n "${_suite_buffer}"
  _suite_buffer=""
}

buffer() {
  local output
  output="$("$@"; printf "x")" # use x marker to avoid losing trailing newlines
  _buffer="${_buffer}${output%x}"
}

flush() {
  echo -n "${_buffer}"
  _buffer=""
}

log() {
  _buffer_log="${_buffer_log}
$1"
}

flush_log() {
  if [[ -n "${_buffer_log}" ]]; then
    buffer fail "${_buffer_log}"
    _buffer_log=""
  fi
}

finish_file() {
  if [[ "${class-JUNIT_FORMATTER_NO_FILE_ENCOUNTERED}" != JUNIT_FORMATTER_NO_FILE_ENCOUNTERED ]]; then
    file_header
    printf "%s\n" "${_buffer}"
    file_footer
  fi
}

finish_suite() {
  flush_log
  suite_header
  suite_flush
  finish_file # must come after suite flush to not print the last file before the others
  suite_footer
}

header_pattern='[0-9]+\.\.[0-9]+'
IFS= read -r header

if [[ ! "$header" =~ $header_pattern ]]; then
  # If the first line isn't a TAP plan, print it and pass the rest through
  printf "junit formatter: This is not the expected TAP format!" >&2
  printf '%s\n' "$header"
  exec cat
  exit 1
fi

# given a prefix and a path, remove the prefix if the path starts with it
# e.g. 
# remove_prefix /usr/bin /usr/bin/bash -> bash
# remove_prefix /usr /usr/lib/bash -> lib/bash
# remove_prefix /usr/bin /usr/local/bin/bash -> /usr/local/bin/bash
remove_prefix() {
  base_path="$1"
  path="$2"
  if [[ "$path" == "$base_path"* ]]; then
    # cut off the common prefix
    printf "%s" "${path:${#base_path}}"
  else
    printf "%s" "$path"
  fi
}

init_suite
trap finish_suite EXIT

while IFS= read -r line; do
  case "$line" in
  "suite "*)
    flush_log
    suite_buffer finish_file
    init_file
    suite_expr="suite (.*)"
    if [[ "$line" =~ $suite_expr ]]; then
      class="$(remove_prefix "$BASE_PATH" "${BASH_REMATCH[1]}")"
    fi
    ;;
  "begin "*)
    flush_log
    ((index += 1))
    name="${line#* $index }"
    ;;
  "ok "*)
    ((file_count += 1))
    expr_ok="ok $index .* in ([0-9]+)ms"
    expr_skip="ok $index .* # skip[ ]?(.*)"
    if [[ "$line" =~ $expr_skip ]]; then
      ((file_skipped += 1))
      test_exec_time=0
      buffer skip "${BASH_REMATCH[1]}"
    elif [[ "$line" =~ $expr_ok ]]; then
      test_exec_time="${BASH_REMATCH[1]}"
      file_exec_time="$((file_exec_time + test_exec_time))"
      suite_test_exec_time=$((suite_test_exec_time + test_exec_time))
      buffer pass
    else
      log "Wrong output format: ${line}"
      ((file_failures += 1))
    fi
    ;;
  "not ok "*)
    ((file_count += 1))
    ((file_failures += 1))
    expr_notok="not ok $index .* in ([0-9]+)ms"
    if [[ "$line" =~ $expr_notok ]]; then
      test_exec_time="${BASH_REMATCH[1]}"
      suite_test_exec_time=$((suite_test_exec_time + test_exec_time))
    else
      log "Wrong output format: ${line}"
    fi
    ;;
  "# "*)
    log "${line:2}"
    ;;
  *)
    echo "$line"
    ;;
  esac
done
